--- a/kernelSim.c
+++ b/kernelSim.c
@@
-        test = read(fifoan1, &bufferan1, 1);
+        test = read(fifoan1, &bufferan1, 1);
         if (test < 0) {
             // CORREÇÃO: EAGAIN em O_NONBLOCK significa "sem dados agora"; não é erro fatal
             if (errno == EAGAIN) {
-                bufferan1 = 0; // sem pedido nesta rodada
+                bufferan1 = 0; // CORREÇÃO: sem syscall nesta rodada; seguir fluxo normal
             }
             else {
                 perror("[KernelSim]: Erro ao ler da FIFOAN1. Saindo...");
                 exit(-22);
             }
         }
@@
-        if (bufferan1 == '1' || bufferan1 == '2'){
+        if (bufferan1 == '1' || bufferan1 == '2'){
             test = read(fifoan2, &bufferan2, 1);
             if (test <= 0) {
                 // CORREÇÃO: se não chegou op ainda, trate como ausência de syscall completa
                 if (test < 0 && errno == EAGAIN) {
                     // volta ao fluxo normal; não há syscall completa
                 }
                 else {
                     perror("[KernelSim]: Erro ao ler da FIFOAN2. Saindo...");
                     exit(-24);
                 }
             }
@@
             // CORREÇÃO: preempção imediata por syscall (parar o processo agora)
             test = kill(currentProcess, SIGSTOP);
             if (test == -1) {
                 perror("[KernelSim]: Erro ao enviar sinal SIGSTOP por syscall. Saindo...");
                 exit(-99);
             }
 
             // CORREÇÃO: solta a CPU; quem volta a rodar será escolhido após a próxima IRQ
             currentProcess = -1;
             continue;
-}
+        }
 
-        else if (bufferan1 == EOF) {
-            // currentProcess não escreveu em FIFOAN1, então não se faz nada
-        }
-
-        else {
-            // Erro
-            perror("[KernelSim]: Erro: Opcao inexistente para bufferan1. Saindo...");
-            exit(-23);
-        }
+        else {
+            // CORREÇÃO: sem syscall nesta rodada (bufferan1 == 0 ou qualquer outro ruído). Não faz nada.
+        }
@@
-        if (currentInfo->PC >= MAX) {
-            //Processo não volta a ser escalonado
-            currentInfo->state = TERMINATED;
-            terminatedProcessess++;
-        }
+        if (currentInfo->PC >= MAX) {
+            //Processo não volta a ser escalonado
+            currentInfo->state = '4'; // CORREÇÃO: TERMINATED como caractere para ICS imprimir com %c
+            terminatedProcessess++;
+        }
@@
-        if (lastSignal == SIG_IRQ0 || lastSignal == SIG_IRQ1 || lastSignal == SIG_IRQ2) {
+        if (lastSignal == SIG_IRQ0 || lastSignal == SIG_IRQ1 || lastSignal == SIG_IRQ2) {
             if (currentInfo->state != TERMINATED) {
                 //Processo volta a ser escalonado pois currentProcess.PC < MAX
                 
                 if (lastSignal == SIG_IRQ0) {
-                    // CORREÇÃO: PC++ acontece no fim da fatia de tempo
-                    // CORREÇÃO: PC++ deve ocorrer apenas no IRQ0
-                    // currentInfo->PC = currentInfo->PC + 1;
-                    currentInfo->state = '0'; // CORREÇÃO: preemptado por IRQ0 (char)
+                    // CORREÇÃO: PC++ acontece no fim da fatia de tempo (apenas no IRQ0)
+                    currentInfo->PC = currentInfo->PC + 1;
+                    currentInfo->state = '0'; // preemptado por IRQ0 (char)
                     test = kill(currentProcess, SIGSTOP);
                     if (test == -1) {
                         perror("[KernelSim]: Erro ao mandar um SIGSTOP para algum AN. Saindo...");
                         exit(-19);
                     }
 
+                    // CORREÇÃO: se atingiu MAX, finalizar e não reencolar
+                    if (currentInfo->PC >= MAX) {
+                        currentInfo->state = '4'; // TERMINATED (char)
+                        terminatedProcessess++;
+                    }
                 }
 
                 else if (lastSignal == SIG_IRQ1) {
-                    if (!empty(&waitingD1)) {
-                        currentProcess = pop(&waitingD1);
-                    }
+                    if (!empty(&waitingD1)) {
+                        pid_t acordadoD1 = pop(&waitingD1); // CORREÇÃO: não sobrescrever o processo em execução
+                        // Atualiza info do acordado e o coloca em ready (se não terminou)
+                        int pn = getProcessNumber(acordadoD1, pd);
+                        Info *infA = info[pn - 1];
+                        if (infA->state != '4') {
+                            push(&ready, acordadoD1);
+                        }
+                    }
                 }
 
                 else {
-                    if (!empty(&waitingD2)) {
-                        currentProcess = pop(&waitingD2);
-                    }
+                    if (!empty(&waitingD2)) {
+                        pid_t acordadoD2 = pop(&waitingD2); // CORREÇÃO: idem para D2
+                        int pn = getProcessNumber(acordadoD2, pd);
+                        Info *infA = info[pn - 1];
+                        if (infA->state != '4') {
+                            push(&ready, acordadoD2);
+                        }
+                    }
                 }
 
-                // Atualiza currentInfo, pois pode se tratar de outro process
-                processNumberValue = getProcessNumber(currentProcess, pd); // CORREÇÃO: recalcular número do processo
-                currentInfo = info[processNumberValue - 1];
-
-                if (currentInfo->state != TERMINATED) {
-                    push(&ready, currentProcess);
-                }
+                // CORREÇÃO: no IRQ0, reencola o processo preemptado (se não terminou).
+                if (lastSignal == SIG_IRQ0) {
+                    if (currentInfo->state != '4') {
+                        push(&ready, currentProcess);
+                    }
+                }
             }
             
         }
 
         else {
             perror("[KernelSim]: Erro: lastSignal enviado por ICS para KernelSim invalido. Saindo...");
             exit(-25);
         }
 
         // CORREÇÃO: zera lastSignal após tratar a interrupção
         lastSignal = -1;
 
-        //Coloca currentProcess novamente na fila de prontos, pois está pronto para ser posteriormente escalonado.
+        // (sem ação aqui; reencolamento já foi feito nos ramos corretos acima)